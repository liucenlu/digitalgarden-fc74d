---
{"dg-publish":true,"permalink":"/02_Javascript/javascript-particular/3.运算符/","created":"2025-07-09T20:07:40.258+08:00","updated":"2025-07-14T15:47:51.376+08:00"}
---

# 1.运算符概述

变量和数据类型，解决数据存放问题
运算符，解决数据运算的问题，面试题密集

## 操作符和操作数

操作符：运算符，参与运算的符号

操作数：参与运算的数据，也称之为“元”

操作符不一定只有一个符号

操作符出现在不同的位置，可能具有不同的含义

```js
1-2;
-1.2;
```

目前接触的操作符：

1. ``` = ```：赋值符号，将右边的数据赋值给左边
2. ``` . ```: 访问符号，用于访问对象的属性
3. ``` [] ```：访问符号，用于访问对象的属性
4. ``` () ```：函数调用

## 分类

按操作数数量区分：

1. 一元（目）运算符：()  .  []
2. 二元（目）运算符: +  -  / * % = 
3. 三元（目）运算符: ?:

功能区分：

1. 算术运算符（数学）
2. 比较运算符
3. 逻辑运算符
4. 位运算符
5. 其他


## 表达式

表达式 = 操作符 + 操作数

每个表达式都有一个运算结果，该结果叫做**返回值**，返回值的类型叫做**==返回类型==**

所有的表达式都可以当作数据使用。


目前学习的运算符的返回值和类型

1. ```=```：该表达式，返回赋值的结果
2. ```.```：属性访问表达式，返回的是属性的值
3. ```[]```：属性访问表达式，返回的是属性的值
4. ```()```：函数调用表达式，返回的结果取决于函数的运行

console.log函数调用的返回结果为undefined


> chrome浏览器控制台的环境是REPL环境
> REPL：Read Eval Print Loop，读-执行-打印-循环
> 当直接在控制台书写代码时，除了运行代码之外，还会输出其返回值，若无返回值则输出undefined

![image-20250708194435100](/img/user/02_Javascript/javascript-particular/图片/运算符/image-20250708194435100.png)

undefined是表达式`console.log(abc);`的返回值，

- 没有写 `return` 的函数，**默认返回 `undefined`**

- 此时“返回值”是 `undefined`，但没有对应“表达式结果”

![image-20250708194451853](/img/user/02_Javascript/javascript-particular/图片/运算符/image-20250708194451853.png)

1是表达式`a=1;`



## 语句

`var a = 1;`是一个语句，声明语句，

在浏览器控制台中，每条输入语句，**不仅会执行**，**还会返回其“值”用于显示结果**。

但 `var a = 1;` 是一条**声明语句**，而**语句在 JS 中没有值，结果是 `undefined`**。



## 区分语句和表达式

### ✅ 1. `var a = 1;` 是**语句（statement）**，不是表达式

- 表达式是有值的，例如 `a = 1` 表达式的值是 `1`
- 语句没有值，例如 `var a = 1`、`if (...) {...}`、`for (...) {...}` 等

浏览器控制台执行代码后，会自动显示**该语句的“结果”**。而声明语句的结果是 `undefined`，所以你看到的是：

```js
undefined
```

------

### ✅ 2. 对比：表达式有返回值

```js
a = 1   // 输出：1
```

- 这是一个赋值表达式，结果是 1，控制台显示的是 `1`

# 2.算术运算符

数学运算符

1. ```+ - * /```
2. ```+ -```
3. ```%```
4. ```++ --``` (下节课讨论)
5. ```**``` 幂

## 细节

1. 数字运算是不精确的

2. 除数为0的情况下

    如果被除数是正数，得到结果 Infinity （正无穷）
    如果被除数是负数，得到结果 -Infinity （负无穷）
    如果被除数是0，得到结果 NaN （Not a Number，非数字）

    ![image-20250708202428285](/img/user/02_Javascript/javascript-particular/图片/算术运算符/image-20250708202428285.png)

    > typeof函数返回类型为string
    > isNaN函数，该函数用于判断一个数据是否是NaN，返回boolean
    > isFinite函数，该函数用于判断一个数据是否是有限的，返回boolean

    ![image-20250708200904037](/img/user/02_Javascript/javascript-particular/图片/算术运算符/image-20250708200904037.png)

3. 求余

    %，有的教程称之为求模

    余数的符号，与被除数相同。
    
    ![image-20250708201821255](/img/user/02_Javascript/javascript-particular/图片/算术运算符/image-20250708201821255.png)

4. 指数

   `**`

   ![image-20250708202040100](/img/user/02_Javascript/javascript-particular/图片/算术运算符/image-20250708202040100.png)

## 其他类型使用算术运算（面试常考）

1. 除加号之外的算术运算符

    将原始类型转换为数字类型（自动完成转换），然后进行运算。

    - boolean： true -> 1, false -> 0
    - string: 如果字符串内部是一个正确的数字，直接变为数字，如果是一个非数字，则得到NaN（能识别Infinity，不能把字符串内部的东西当作表达式），如果字符串是一个空字符串（没有任何内容），转换为0. 字符串转换时，会忽略前后空格。
    > NaN虽然是数字，但它和任何数字作任何运算，得到的结果都是NaN

    - null：null -> 0
    - undefined: undefined -> NaN
    - Object

        将对象类型先转换为字符串类型，然后再将该字符串转换为数字类型

        对象类型{} -> "[object Object]" -> NaN
        
        ![image-20250708203719510](/img/user/02_Javascript/javascript-particular/图片/算术运算符/image-20250708203719510.png)
        
        因为js允许语句结尾不写分号所以会产生歧义导致报错

2. 加号运算符

    - 加号一边有字符串，含义变为==字符串拼接==

        将另一边的其他类型，转换为字符串

        - 数字 -> 数字字符串
        - boolean -> boolean字符串
        - null -> "null"
        - undefined -> "undefined"
        - 对象 -> "[object Object]"

    - 加号两边都没有字符串，但一边有对象，将对象转换为字符串，然后按照上面的规则进行

        - ![image-20250708204640641](/img/user/02_Javascript/javascript-particular/图片/算术运算符/image-20250708204640641.png)
    
    - 其他情况和上面的数学运算一致
    
    ```js
            console.log(1 + 2 * 3); // 7
            console.log(1 + 3 % 2); // 2
            console.log("" + 3 % 2);// "1"
            console.log(+"" + 3 % 2); // 1
            console.log(+{} + ""); //"NaN"
            console.log(100 % 4 / 0); //NaN
            console.log(null / null); //NaN
            var a;
            console.log(a + {} + 123); //undefined[object Object]123
            console.log(1 + "" + 2 + 3); //"123"
            console.log({} * null); //NaN
            console.log(+"" + 100); //100
    ```
    
    

## 作业

1. 温度转换器

    设置一个变量，保存摄氏温度（C），将其转换为华氏温度（F）

    F = (9/5)C + 32

2. 利息计算器

    设置变量，分别存放本金、月数、年利率，计算利息

# 3.自增和自减

## 基本功能

一元运算符

++：将某个变量的值自增1

--：将某个变量的值自减1

## 细节

### 自增自减表达式

x++: 将变量x自增1，得到的表达式的值是自增之前的值。
++x: 将变量x自增1，得到的表达式的值是自增之后的值。
x--: 将变量x自减1，得到的表达式的值是自减之前的值。
--x: 将变量x自减1，得到的表达式的值是自减之后的值。

```js
var x = 0;
//输出表达式x++的返回值
console.log(x--);//0
console.log(x);//-1
```



### 优先级

从高到底依次是：

1. ```++ --```
2. ```* / %```
3. ```+ -```

优先级的运算细节：

1. 从左到右依次查看
2. 如果遇到操作数，将数据的值直接取出
3. 如果遇到相邻的两个运算符，并且左边的运算符优先级大于等于右边的运算符，则直接运行左边的运算符。

```js
var x = 1;
//var y = x + x++ * ++x;
//y = 1 + 1* 3=4
//var y = x++ + ++x + x++ * ++x + ++x;
// y=1+3+3*5+6=25
var y = x + x++ * (x = x + x++ * ++x) + x;
//y = 1 +1*(10)+10=21
console.log(y);
```

# 4.比较运算符

大小比较：`>   <    >=    <=`
相等比较：`==   !=   ===   !==`

**比较运算符的返回类型：boolean**

**算术运算符的优先级高于比较运算符**

## 大小比较(面试)

### 细节

1. 两个字符串比较大小，比较的是字符串的字符编码（排序，按字典序）。

    ```js
    var a = 5,
        b = 4;
    console.log(2 + 3 >= 5);//true
    console.log('A' > 'B');
    //相当于65>66 false
    console.log('AB' > 'AC');//false
    console.log("11" > "1");//true 逐个比较字符编码
    console.log(a > b);
    ```

    

2. 如果一个不是字符串，并且两个都是原始类型，将它们都转换为数字进行比较

    '1' -> 1
    '' -> 0
    '   ' -> 0
    '  a' -> NaN
    '3.14' -> 3.14

    NaN与任何数字比较，得到的结果都是false

    Infinity比任何数字都大

    -Infinity比任何数字都小

    ```js
    console.log('1' >= 10);//false
    console.log('2' > true);//true
    console.log(NaN > 0);//false,NaN与任何数字比较，得到的结果都是false
    console.log(3 > {});//false,{}->'[object object]'->NaN
    console.log(null > -1);//true
    console.log(undefined > -1);//false,undefined->NaN
    ```

    

3. 如果其中一个是对象，将对象转换为原始类型然后，按照规则1或规则2进行比较

  目前，对象转换为原始类型后，是字符串 "[object Object]"



## 相等比较

### `==` 和 `!=` (相等比较 和 不相等比较)

\==: 比较两个数据是否相等
!=: 比较两个数据是否不相等

**细节**

1. 两端的类型相同，直接比较两个数据本身是否相同（两个对象比较的是地址）

2. 两端的类型不同
    1). null 和 undefined， 它们之间相等， 和其他原始类型比较， 则不相等。
    2). 其他原始类型，比较时先转换为数字，再进行比较
    3). NaN与任何数字比较，都是false，包括自身
    4). Infinity和-Infinity，只能和自身相等
    5). 对象比较时，要先转换为原始类型后，再进行比较

```js
        var a = {};
        var b = {};
        //两端的类型相同，直接比较两个数据本身是否相同（两个对象比较的是地址）
        console.log(1 == 1);//true
        console.log(1 != 1);//false
        console.log("abc" === "abc");//true
        console.log("abc " !== "abc");//true
        console.log(a == b); // false,两个不同对象地址不同

        //两端的类型不同
        // null 和 undefined， 它们之间相等， 和其他原始类型比较， 则不相等。
        console.log(null == undefined); // true
        console.log(null != undefined); // false
        console.log(null == 0); // false
        console.log(undefined == 0); //false

        //其他原始类型，比较时先转换为数字，再进行比较
        console.log('1' == 1); // true
        console.log(true == 1);  //true
        console.log(true == 2); //false
        console.log(true == '1'); // true

        //NaN与任何数字比较，都是false，包括自身
        console.log(NaN == NaN);//false
        // 对象比较时，要先转换为原始类型后，再进行比较
        console.log({} == 0); // false,{}->[object Object]->NaN
```



**由于相等和不相等比较，对于不同类型的数据比较违反直觉，因此，通常我们不适用这种比较方式，而是使用更加接近直觉的==严格相等和严格不相等比较==**

```js
null > 0 //false
null >= 0//true
null == 0//false,因为==相等比较的特殊规则导致的奇怪现象
```




### `===` 和 `!==` （严格相等 和 严格不相等）

`===` ： 两端的数据和类型必须相同
`!==` ： 两端的数据或类型不相同

1. 两端类型相同，规则和相等比较一致。
2. 两端类型不同，为false。

数字规则：

1). NaN与任何数字比较，都是false，包括自身
2). Infinity和-Infinity，自能和自身相等

3).+0和-0相等

```js
console.log(1 === true); // false
console.log(NaN === NaN);//false
console.log(0 === -0);//true
```

# 6.逻辑运算符

布尔运算符

返回类型不一定是Boolean

## 细节（面试）

## 与（并且）

符号：&&

书写方式： 表达式1 && 表达式2

1. 将表达式1 进行 boolean 判定

    以下数据均判定为false：

    1) null
    2) undefined
    3) false
    4) NaN
    5) ''
    6) 0

    其他数据全部为真

2. 如果表达式1的判定结果为假，则==直接返回表达式1==，而不执行表达式2；否则，返回==表达式2==。 （短路求值规则）

```js
console.log(5 > 3 && 3 > 2);//true,5 > 3优先级较高->true,此时表达式1为true而不是5>3
console.log(5 > 3 && 100);//100
console.log(0 && 2);//0

var x = 1;
console.log(x > 2 && x++ > 0);//false
console.log(x);//1

console.log(1 && 2 && 3 && 4 && 0 && 5 && 6 && 7);//0

var age = -10;
// 如果年龄为负数，则将其设置为0
age < 0 && (age = 0); 

console.log(age);//0

var x = 1;
console.log(x++ >= 1 && x++ >= 2 && x++ >= 4 && x++ >= 4);//false
console.log(x);//4
```



## 或

符号：||

写法：表达式1 || 表达式2

1. 将表达式1 进行 boolean 判定

2. 如果表达式1为真，直接返回表达式1，不运行表达式2；否则，返回表达式2

```js
        console.log(1 > 3 || 10);//10

        console.log(undefined || 'abc');//'abc'

        console.log(0 || null || undefined || 1 || null || NaN);//1

        var obj = {
            name: "xxx",
            gender: "男"
        };

        // 对象中如果没有年龄(undefined)，则将年龄赋值为18

        // obj.age = obj.age === undefined && 18;
        obj.age = obj.age || 18;
```



## 非

符号：!

写法: !数据

一元运算符

将数据的boolean判定结果直接取反，非运算符一定返回boolean类型。

# 7.三目运算符

书写方式： 表达式1 ? 表达式2 : 表达式3

1. 对表达式1进行boolean判定
2. 如果判定结果为真，返回表达式2；否则，返回表达式3。

```js
var year = 2000;
//是否是闰年
var isLeap = year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
//得到该年份二月的天数
var days = isLeap ? 29 : 28;
console.log("二月的天数为：" + days);
```

```js
var x = 1;
x = x++ >= 1 ? x++ * x++ : ++x * ++x;
console.log(x);//6
```

# 8.补充知识

## 模板字符串
1. 模板字面量：\`字符串\`
2. 字符串插值：`${表达式}`

模板字面量最常用的一个特性是支持字符串插值

```js
        var user = {
            age: 18,
            name: "成哥",
            gender: "男"
        };

        // 输出： 我叫xxx，今年xxx岁了，性别是xxx，目前已成年（未成年）
        console.log("我叫" + user.name +
            "，今年" + user.age +
            "岁了，性别是" + user.gender +
            "，目前" + (user.age >= 18 ? "已成年" : "未成年"));

        console.log(`我叫${user.name}，今年${user.age}岁了，性别是${user.gender}，目前${user.age>=18?"已成年":"未成年"}`);
```



## 类型转换不会影响原本的数据

```js
        var x = '1';
        var y = x * 2;
        console.log(y);//2
        console.log(x, typeof x);//'1' 'string'
```



## 复合的赋值运算符

+=  -=  /=  *=  %=  **=

## void 运算符

一元运算符

写法：

1. 普通写法： ``` void 表达式  ```
2. 函数写法： ``` void(表达式)  ```

优先级较高，使用时最好加上（）

作用：运行表达式，然后返回undefined

![image-20250709145711972](/img/user/02_Javascript/javascript-particular/图片/运算符补充/image-20250709145711972-1752044234856-3-1752044240218-5-1752044252341-7.png)

## typeof 运算符

一元运算符

写法：

1. 普通写法： ``` typeof 表达式  ```
2. 函数写法： ``` typeof(表达式)  ```

优先级较高，使用时最好加上（）

typeof运算，返回表达式的类型，是一个字符串。

![image-20250709145513211](/img/user/02_Javascript/javascript-particular/图片/运算符补充/image-20250709145513211-1752044117784-1.png)

## 逗号运算符

写法：表达式1, 表达式2, 表达式23 表达式4

依次运行每个表达式，返回最后一个表达式

> 逗号运算符的优先级比赋值更低

![image-20250709145904514](/img/user/02_Javascript/javascript-particular/图片/运算符补充/image-20250709145904514.png)
# 9.数字的存储

**在对精度要求很高的系统中，或要对小数的运算结果进行比较时，需要特别谨慎**

## 问题

1. JS中的小数运算是精确的吗？

  不一定

  ![image-20250709150915659](/img/user/02_Javascript/javascript-particular/图片/数字的存储/image-20250709150915659.png)

2. JS中的整数运算是精确的吗？

  不一定

  ![image-20250709150954678](/img/user/02_Javascript/javascript-particular/图片/数字的存储/image-20250709150954678.png)

3. JS中表示的整数是连续的吗？

	不是，当JS的数字很大的时候，不再连续。

4. JS中表示的最大数字是多少？

  最大连续整数：9007199254740991

  ![image-20250709151234342](/img/user/02_Javascript/javascript-particular/图片/数字的存储/image-20250709151234342.png)

5. JS中能表示的数字的有效位数是多少？

	16 ~ 17



## 二进制

现实世界中：十进制，10个数字，逢十进一

计算机世界中：二进制，2个数字，逢二进一

二进制 -> 十进制

1101 -> $1*2^3 + 1*2^2 + 0*2^1 + 1*2^0 = 13$

11.01 -> $1*2^1 + 1*2^0 + 0*2^{-1} + 1*2^{-2} = 3.25$

十进制 -> 二进制

13 -> 1101

```
13 / 2  商 6    余  1
6  / 2  商 3    余  0
3  / 2  商 1    余  1
1  / 2  商 0    余  1
余数从下往上看
```

3.25 -> 11.01

整数部分一样

小数部分

```
0.25 * 2    0.5     整数部分：0
0.5  * 2    1.0     整数部分：1
整数部分从上往下看
```

## 为什么JS的小数运算不精确

十进制的小数，转换为二进制后，可能是无限小数，但是计算机对数字的存储能力有限，因此会丢失一些数据。

![image-20250709152137105](/img/user/02_Javascript/javascript-particular/图片/数字的存储/image-20250709152137105.png)

十进制数 0.3 -> 0.010011001100110011001.....

```
0.3*2   0.6     0
0.6*2   1.2     1
0.2*2   0.4     0
0.4*2   0.8     0
0.8*2   1.6     1
0.6*2   1.2     1
0.2*2   0.4     0
......
整数部分从上往下看
```

## JS如何存储数字

整数法、浮点法

JS中，存储的所有数字，都按照浮点法存放。

浮点法存放的数字，叫做浮点数（float），浮点数分为单精度和双精度。

JS中，使用双精度存放浮点数，IEEE 754。

**存放方式**

JS在计算机中，给每个数字开辟一块内存空间，尺寸固定为64位

> 在计算机中，位（bit）是最小的存储单位，简称为bit
> 1 byte = 8 bit
> 1 KB = 1024 byte
> 1 MB = 1024 KB
> 1 GB = 1024 MB

```
[第1段][第2段][第3段]

第1段：1位，表示符号位，如果为1，是负数，如果为0，是正数
第2段：11位，表示指数位，这里的指数是2为底的指数，而不是10
第3段：52位，表示有效数字
```

举例

```
0     1000 0000 011    1111 0000 0000 0000....
```
相当于： $1.1111 * 2 ^ {1027 - 1023} $

**特殊情况**

1. 指数为0，尾数为0，表示数字 0
2. 符号为0，指数为2047，尾数为0，表示正无穷

```
Infinity: 0 11111111111 00000000000...
```

3. 符号为1，指数为2047，尾数为0，表示负无穷

```
-Infinity: 1 11111111111 00000000000...
```

4. 指数为2047，尾数不为0，表示NaN

```
NaN: 1 11111111111 01001010000...
```

**一个正常的数字，指数部分最多是2046**

## 能表示的最大数字

```
0 11111111110 1111111111.........
```

相当于： $1.1111111111... * 2 ^ 1023 $

## 能表示的最大的安全整数

安全数字：从1开始到该数字，均是连续的整数，并且该数字的下一个整数是存在的。

```
0 xxxxx 1111111111....
```

相当于： $2^53 - 1$

下一位： $2^53$   ```0  xxxxx  0000000000000```

# 10.位运算

将一个整数的二进制格式进行运算

js中，如果对一个数据进行位运算，它首先会将其转换为一个整数，并且按照32位的整数二进制排列

举例

```
2.7 -> 2 -> 0000 0000 0000 0000 0000 0000 0000 0010

NaN -> 0

Infinity -> 0

-Infinity -> 0
```

## 位与运算

符号：&

写法：整数1 & 整数2

将两个整数每一位进行比较，如果都为1，结果为1，否则结果为0.

![image-20250709154719972](/img/user/02_Javascript/javascript-particular/图片/位运算/image-20250709154719972.png)

![image-20250709154725815](/img/user/02_Javascript/javascript-particular/图片/位运算/image-20250709154725815.png)



## 或运算

符号：|

写法：整数1 | 整数2

将两个整数每一位进行比较，如果都为0，结果为0，否则结果为1.

```js
// 001
// 100
// = 
// 101
console.log(1 | 4);
```



## 否（非）运算

符号：~

写法：~整数

将该整数按位取反

**负数的存储方式**

-1

真码：1000 0000 0000 0000 0000 0000 0000 0001
反码：1111 1111 1111 1111 1111 1111 1111 1110  真码取反,除符号位之外
补码：1111 1111 1111 1111 1111 1111 1111 1111  反码加1  -1**最终的存储方案**（因为计算机做不了减法）

取反的快速运算：- 数字 - 1

```js
        // 0000 0000 0000 0000 0000 0000 0000 0001
        // = 
        // 1111 1111 1111 1111 1111 1111 1111 1110
        // 反码：1111 1111 1111 1111 1111 1111 1111 1101
        // -2,-1-1=-2
        console.log(~1);
```



JS中最快速的取整的方式：``` ~~整数 ```

```js
        // 快速取整
        // ~~3.65645 = ~~3 = ~-4 = 3
        console.log(~~3.65645);
```



## 异或运算

符号：^

写法：数字1 ^ 数字2

将数字1和数字2按位比较，不同取1，相同取0

```js
        // 交换变量
        var a = 5, b = 3;

        // 方式1
        // var temp = a;
        // a = b;
        // b = temp;
        // console.log(a, b);

        // 方式2
        // a = a + b;
        // b = a - b; 
        // a = a - b;
        // console.log(a, b);

        // 方式3
        // 101
        // 011
        a = a ^ b; // 110
        b = a ^ b; // 110 ^ 011  = 101 = 5
        a = a ^ b; // 110 ^ 101  = 11 = 3
        console.log(a, b);
```



## 应用场景

位的叠加（开关）

```js
//保存了所有可能的权限
var perm = {
    read: 0b001, //读权限
    write: 0b010, //写（修改）权限
    create: 0b100 //创建权限
    // 1表示有权限
};
//变量p中保存可读可写
var p = perm.create | perm.write;

//去掉可读权限
p = p | perm.read ^ perm.read;

//判断权限：p中是否有可读权限
// p: 011  & 001  = 001
p & perm.read === perm.read ? console.log("可读") : console.log("不可读");
```



## 位移运算

- 左位移： <<

    写法： 数字a << 数字b   结果： 数字$a * 2 ^ b$

    将数字1的二进制（除符号之外，左移动数字2的次数）

- 右位移：>>

	写法： 数字1 >> 数字2   结果： 整数(数字1 / 2 ^ 数字2)

- 全右位移：>>>

	与右位移的区别，在于全右位移会导致符号位跟着位移。

```js
// 0000 0000 0000 0000 0000 0000 0000 0011
// 0000 0000 0000 0000 0000 0000 0000 0110
console.log(3 << 1);//6

// 1000 0000 0000 0000 0000 0000 0000 0011
// 1000 0000 0000 0000 0000 0000 0000 1100
console.log(-3 << 2);//-12

// 0000 0000 0000 0000 0000 0000 0000 0011
// 0000 0000 0000 0000 0000 0000 0000 0001
console.log(3 >> 1);//1
```

# 11.求余和求模

% ：求余(rem)

x % y

1. 求余 x rem y:  x - n * y, n表示商取整（直接去掉小数，向0取整）

```js
x = 7, y = 3   

n = x / y = 2.333333 ≈ 2

x rem y = x - n * y = 7 - 2 * 3 = 1
```

```js
x = 7, y = -3  

n = 7 / -3 = -2.33333 ≈ -2

x rem y = x - n * y = 7 - (-2)*(-3) = 7 - 6 = 1
```

```js
x = -7, y = 3  

n = -7 / 3 = -2.33333 ≈ -2

x rem y = x - n * y = -7 - (-2)*3 = -7 + 6 = -1
```

**余数和被除数的符号相同**

求模(mod)

2. 求模 x mod y:  x - n * y, n表示商取整（向下取整，向数轴左边取整）

```js
x = 7, y = -3

n = 7 / -3 = -2.3333 ≈ -3

x mod y = x - n * y = 7 - (-3)*(-3) = 7 - 9 = -2
```

```js
x = -7, y = 3

x mod y = x - n * y = -7 - (-3)*3 = -7 + 9 = 2

n = -7 / 3 = -2.3333 ≈ -3
```

**求模的符号与除数相同**



**求余和求模只有在商为负数时会产生不同结果**
