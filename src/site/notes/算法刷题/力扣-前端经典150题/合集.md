---
{"dg-publish":true,"permalink":"/算法刷题/力扣-前端经典150题/合集/","created":"2025-05-27T15:37:46.025+08:00","updated":"2025-06-23T20:06:15.274+08:00"}
---

## [26. 删除有序数组中的重复项 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/description/?envType=study-plan-v2&envId=top-interview-150)

#数组 #双指针 

![](/img/user/算法刷题/力扣-前端经典150题/attachments/20250527154149.png)

> [!NOTE]-
> 思路：
> 1. **初始化变量**：定义变量`cur`为 0 ，它将作为不重复元素的数组下标指针。
> 2. **遍历数组**：使用`for`循环遍历数组`nums`，`p`作为遍历指针。
> 3. **判断与赋值**：在循环中，比较`nums[p]`和`nums[cur]`，若不相等，说明遇到新元素，`cur`自增 1 ，并将`nums[p]`赋值给`nums[cur]` 。
> 4. **返回结果**：循环结束后，`cur + 1`就是不重复元素的个数，返回该值。 整体是利用双指针思想，一个指针遍历数组找新元素，一个指针记录不重复元素的存储位置。

## [80. 删除有序数组中的重复项 II - 力扣（LeetCode）](https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii/?envType=study-plan-v2&envId=top-interview-150)

#数组 #双指针 

![](/img/user/算法刷题/力扣-前端经典150题/attachments/20250527154140.png)

> [!NOTE]-
> 思路：
> 1. 初始化
> 	定义变量`cur`为 0，作为处理后不重复元素（满足最多出现两次）在数组中的存储指针。
> 2. 遍历数组
> 	使用`for`循环，`p`作为遍历数组`nums`的指针，从索引 1 开始遍历整个数组。
> 3. 分类判断处理
> 	**重复元素情况**：当`nums[p]`等于`nums[cur]` ，说明遇到重复元素。此时进一步判断，若`cur`为 0（指向数组第一个元素，肯定不会重复超两次 ），或者前一个元素`nums[cur - 1]`不等于当前重复元素`nums[p]`（即当前元素重复次数未超两次 ），就将`nums[p]`赋值给`nums[++cur]` ，更新不重复元素存储位置。
> 	**非重复元素情况**：当`nums[p]`不等于`nums[cur]` ，说明遇到新元素，直接将`nums[p]`赋值给`nums[++cur]` 。
> 4. 返回结果
> 	循环结束后，`cur + 1`就是处理后数组的新长度，返回该值。 本质上也是双指针思路，一个指针遍历数组，一个指针维护满足条件的不重复元素存储位置。

## [125. 验证回文串 - 力扣（LeetCode）](https://leetcode.cn/problems/valid-palindrome/?envType=study-plan-v2&envId=top-interview-150)

#双指针 #字符串 
![](/img/user/算法刷题/力扣-前端经典150题/attachments/20250527170626.png)

> [!NOTE]-
> 思路：
> - **`replace(/[^a-zA-Z0-9]/g, "")`**：
>     
>     - 使用正则表达式`[^a-zA-Z0-9]`匹配**所有非字母和数字的字符**（`^`表示取反）。
>     - `g`标志表示全局匹配，替换所有符合条件的字符为空字符串`""`。
> - **`replace(/\s/g, "")`**：
>     
>     - 使用正则表达式`\s`匹配**所有空白字符**（包括空格、制表符、换行符等）。
>     - 同样用`g`标志全局替换为空字符串。
> - **`toLowerCase()`**：
>     
>     - 将处理后的字符串转换为小写，确保比较时忽略大小写。
> 
> - **`[...s]`**：
>     
>     - 使用扩展运算符`...`将字符串拆分为字符数组。例如，`"abc"`变为`['a', 'b', 'c']`。
> - **`.reverse()`**：
>     
>     - 调用数组的`reverse()`方法将数组元素顺序颠倒。例如，`['a', 'b', 'c']`变为`['c', 'b', 'a']`。
> - **`.join("")`**：
>     
>     - 将颠倒后的数组重新连接成字符串。例如，`['c', 'b', 'a']`变为`"cba"`。
> - **`s == = ...`**：
>     
>     - 比较原字符串`s`和反转后的字符串是否完全相同。如果相同，则返回`true`（是回文）；否则返回`false`。


## [392. 判断子序列 - 力扣（LeetCode）](https://leetcode.cn/problems/is-subsequence/?envType=study-plan-v2&envId=top-interview-150)

#双指针 #字符串 #动态规划

![](/img/user/算法刷题/力扣-前端经典150题/attachments/20250527172317.png)

> [!NOTE]-
> - **双指针法**：使用双指针分别指向`s`和`t` ，从字符串开头开始遍历，当字符匹配时，两个指针都前进一步；不匹配时，仅移动指向`t`的指针。这样时间复杂度可以优化到O(m+n) 。
> - **提前终止条件**：当`s`的指针遍历完`s`（说明`s`是`t`的子序列 ）或者`t`的指针遍历完`t`但`s`还没遍历完（说明`s`不是`t`的子序列 ）时，提前终止循环并返回结果。

## [209. 长度最小的子数组 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-size-subarray-sum/?envType=study-plan-v2&envId=top-interview-150)
#数组 #二分查找 #前缀和 #滑动窗口

![](/img/user/算法刷题/力扣-前端经典150题/attachments/20250527193748.png)

> [!NOTE]-
> 思路
> 
> 1. **初始化变量**
>     - `left`和`right`是滑动窗口的左右边界，初始时都指向数组的起始位置（`left = 0`，`right = 0` ）。
>     - `sum`用于记录滑动窗口内元素的总和，初始化为 0 。
>     - `minLength`用于记录满足条件的最小子数组长度，初始化为一个很大的值（`Infinity` ），因为一开始还不确定是否存在满足条件的子数组。
> 2. **滑动窗口扩展**
>     - 通过`while (right < nums.length)`循环来扩展滑动窗口的右边界。每次循环将`nums[right]`加入到`sum`中，即`sum += nums[right];` ，然后右边界`right`自增 1 （`right++;` ），这相当于不断把新元素纳入到窗口内。
> 3. **滑动窗口收缩**
>     - 当`sum >= target`时，说明当前滑动窗口内的子数组总和已经满足大于等于`target`的条件了。此时进入内层的`while`循环进行窗口收缩操作：
>         - 首先更新`minLength`，取当前`minLength`和当前窗口长度（`right - left + 1` ）中的较小值，即`minLength = Math.min(minLength, right - left + 1);` ，这样就能记录下到目前为止满足条件的最小子数组长度。
>         - 然后将窗口左边界的元素从`sum`中减去（`sum -= nums[left];` ），并将左边界`left`自增 1 （`left++;` ），这是为了尝试缩小窗口，看能否找到更短的满足条件的子数组。
> 4. **返回结果**
>     - 当整个数组遍历完后，如果`minLength`仍然是初始的`Infinity` ，说明不存在满足条件的子数组，此时返回 0；否则返回`minLength` ，即满足条件的最小子数组长度。
> 
时间复杂度分析
滑动窗口在遍历数组过程中，每个元素最多被左右边界各访问一次，所以时间复杂度是\(O(n)\) ，其中n是数组`nums`的长度，这种方法比暴力枚举的时间复杂度\(O(n^2)\)要高效很多。 空间复杂度为\(O(1)\) ，因为只使用了几个固定的额外变量，与输入数组的规模无关。

## [3. 无重复字符的最长子串 - 力扣（LeetCode）](https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/?envType=study-plan-v2&envId=top-interview-150)

#哈希表 #滑动窗口 #字符串 

![](/img/user/算法刷题/力扣-前端经典150题/attachments/20250529134952.png)

> [!NOTE]
> 思路
> 1. **滑动窗口机制**：
>     
>     - 使用两个指针（`start` 和 `i`）来表示窗口的左右边界。
>     - `start` 指向当前无重复子串的起始位置，`i` 是当前遍历到的字符位置。
> 2. **哈希表记录字符位置**：
>     
>     - 使用 `Map` 存储每个字符及其最后一次出现的索引。
>     - 当遇到重复字符时，通过哈希表快速定位并调整窗口左边界 `start`。
> 3. **动态调整窗口**：
>     
>     - 若当前字符已存在且在窗口内（即上次出现位置 >= `start`），则将窗口左边界移动到重复字符的下一个位置。
>     - 无论是否调整窗口，都更新当前字符的最新位置到哈希表中。
> 4. **复杂度优化**：
>     
>     - 时间复杂度为 O (n)，因为只需遍历一次字符串。
>     - 空间复杂度为 O (min (n, m))，其中 m 是字符集的大小（如 ASCII 字符集为 128）。

## [1. 两数之和 - 力扣（LeetCode）](https://leetcode.cn/problems/two-sum/solutions/657225/tu-jie-guan-fang-tui-jian-ti-jie-liang-s-02xs/?envType=study-plan-v2&envId=top-interview-150)

#哈希表 #数组 

![](/img/user/算法刷题/力扣-前端经典150题/attachments/20250529141437.png)

> [!NOTE]
> 解题思路
> 根据题意，如果使用暴破，会导致时间复杂度为 n^2
>  ，这样的代价无疑是很大的。
> 
> 所以我用哈希表来解决这个问题。
> 
> 遍历到数字 a 时，用 target 减去 a，就会得到 b，若 b 存在于哈希表中，我们就可以直接返回结果了。若 b 不存在，那么我们需要将 a 存入哈希表，好让后续遍历的数字使用。

## [128. 最长连续序列 - 力扣（LeetCode）](https://leetcode.cn/problems/longest-consecutive-sequence/?envType=study-plan-v2&envId=top-interview-150)

#哈希表 #数组 
![](/img/user/算法刷题/力扣-前端经典150题/attachments/20250529144418.png)

> [!NOTE]
> 1. **哈希集合加速查找**：
>     - 将数组转换为 `Set` 后，可以在 O (1) 时间内判断元素是否存在，这是算法高效的关键。
> 2. **确定序列起始点**：
>     - 对于每个元素 `num`，若 `num - 1` 不存在于集合中，则 `num` 是某个连续序列的起始点。
>     - 这避免了对每个元素都进行重复检查，确保每个连续序列只被遍历一次。
> 3. **扩展计算序列长度**：
>     
>     - 从起始点 `num` 开始，不断检查 `num + 1` 是否存在于集合中，并累加长度直到序列中断。
> 4. **复杂度分析**：
>     
>     - **时间复杂度**：O (n)。每个元素最多被访问两次（一次插入集合，一次扩展序列）。
>     - **空间复杂度**：O (n)。主要用于存储集合中的元素。

## [49. 字母异位词分组 - 力扣（LeetCode）](https://leetcode.cn/problems/group-anagrams/?envType=study-plan-v2&envId=top-100-liked)
#数组 #哈希表 #字符串 #排序

![attachments/Paste-image-20250622.png](/img/user/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/%E5%8A%9B%E6%89%A3-%E5%89%8D%E7%AB%AF%E7%BB%8F%E5%85%B8150%E9%A2%98/attachments/Paste-image-20250622.png)

> [!NOTE]
> 思路：
> - 将每个字符串排序，作为 key；
>     
> - 利用 `Map` 存储 key 对应的一组异位词；
>     
> - 最后输出 `Map` 中所有的 value。

## [36. 有效的数独 - 力扣（LeetCode）](https://leetcode.cn/problems/valid-sudoku/description/?envType=study-plan-v2&envId=top-interview-150)

#哈希表 #数组 #矩阵
![attachments/Paste-image-20250623.png](/img/user/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/%E5%8A%9B%E6%89%A3-%E5%89%8D%E7%AB%AF%E7%BB%8F%E5%85%B8150%E9%A2%98/attachments/Paste-image-20250623.png)

> [!NOTE]
> 思路：
> + 准备行、列、3 * 3小方块，三个哈希表或者set或者9 * 9的二维数组，都可以，只要能判重复即可，从上到下，从左到右循环，依次检查行、列、3 * 3小方块中是否有重复的数字，如果有则返回false，然后更新哈希表或者set。
> + 复杂度分析：时间复杂度：O(1)，数独共有 81 个单元格，每个单元格遍历一次即可。空间复杂度：O(1)，数独的大小固定，因此哈希表的空间也是固定的。
