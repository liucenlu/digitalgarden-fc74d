---
{"dg-publish":true,"permalink":"/前端八股/网络相关/http/http各版本相较于上个版本各自做了哪些优化/","created":"2025-06-04T13:43:00.000+08:00","updated":"2025-06-15T17:42:07.398+08:00"}
---



### HTTP 不同版本的主要优化内容
#### http0.9 vs http1.0
http0.9没有头信息，仅支持GET，只支持HTML。

http1.0相对于http0.9有很大改进

1. **支持多种格式文件**，图片、视频、文本等
2. **支持多种请求方法**，POST、HEAD等
3. **请求和响应增加了头信息**
4. **引入状态码定义响应的特征**
5. **缓存**
6. **支持多段类型**，在 RFC 2387 文件中，指出若要传输多种参数，多种资料型态混合的信息时，要先将 HTTP 要求的 Content-Type 设为 multipart/form-data，而且要设定一个 boundary 参数，这个参数是由应用程序自行产生，它会用来识别每一份资料的边界 (boundary)，用以产生多重信息部份 (message part)

#### HTTP 1.0 vs HTTP 1.1
HTTP/1.0 是最早的正式标准化版本，但它存在许多效率低下之处。为了改进这些问题，HTTP/1.1 引入了多项重要特性：

1. **持久连接**  
   HTTP/1.0 默认每次请求都需要重新建立 TCP 连接，而 HTTP/1.1 支持持久连接（也称为长连接），允许在一个 TCP 连接上复用多个请求和响应。这样减少了频繁创建和关闭连接带来的开销。

2. **管道化（Pipelining）**  
   HTTP/1.1 提供了管道化功能，允许多个请求在同一连接上按顺序发出而不必等待前一个请求完成后再发下一个请求。不过，由于队头阻塞等问题，这一特性的实际应用受到一定限制。

3. **缓存控制机制增强**  
   HTTP/1.1 增强了缓存管理能力，引入了 `Cache-Control` 头部字段以及其他相关头部（如 `ETag`, `If-Modified-Since` 等），以便更精确地管理和更新本地缓存中的资源。

4. **主机头字段的支持**  
   随着虚拟主机技术的发展，单台物理服务器可能托管多个域名对应的网站。因此，HTTP/1.1 新增了 `Host` 请求头以区分同一 IP 地址下不同的目标站点。

---

#### HTTP 1.1 vs HTTP 2
尽管 HTTP/1.1 已经显著提高了网络性能，但在面对现代 Web 应用日益复杂的需求时仍显不足。于是，IETF 推出了全新的二进制协议——HTTP/2：

1. **二进制分帧层**  
   HTTP/2 将原本基于文本的消息结构替换成了更为高效的二进制分帧格式，极大地降低了解析成本并提升了兼容性和稳定性。

2. **多路复用（Multiplexing）**  
   在同一个 TCP 连接中可以通过多路复用来并发传输多个消息流，有效解决了 HTTP/1.x 中因依赖单一通道而导致的瓶颈问题。

3. **头部压缩（HPACK Compression）**  
   对于重复出现频率较高的键值对组合采用专门设计的 HPACK 算法进行高效编码压缩，减少冗余数据量的同时加快加载速度。

4. **服务端推送（Server Push）**  
   允许服务器主动向客户端预先发送某些预计会被后续访问所需的静态文件等内容，从而提前做好准备避免额外往返延迟的影响。

---

#### HTTP 2 vs HTTP 3
虽然 HTTP/2 实现了许多突破性进展，但由于仍然运行在传统的 TCP 协议之上，所以不可避免地继承了一些固有缺陷。为此 QUIC 协议应运而生，并作为底层承载基础构建起新一代标准体系——HTTP/3：

1. **基于 UDP 的全新传输协议（QUIC）**  
   相较于 TCP，UDP 更适合实时性强的应用场景需求。通过 QUIC 可以快速建立起稳定可靠的通信链路，同时具备零 RTT 握手优势以及独立丢失恢复机制等特点。

2. **进一步强化多路复用表现**  
   在原有基础上继续深化探索消除串行依赖关系的可能性，即使某个单独的数据包发生丢弃也不会牵连到其他正在处理的任务进程当中去。

3. **内置加密支持**  
   自动开启 TLS 类似级别的安全保障措施，默认情况下所有流量均经过严格验证与封装处理后才予以放行流通。

```python
import http.client

conn = http.client.HTTPSConnection("example.com", port=443)
headers = {'User-Agent': 'Mozilla/5.0'}
conn.request("GET", "/", headers=headers)

response = conn.getresponse()
print(response.status, response.reason)
data = response.read().decode('utf-8')
conn.close()

if "HTTP/3" in data:
    print("Detected support for HTTP/3.")
else:
    print("No explicit mention of HTTP/3 found.")
```

上述代码片段展示了一个简单示例程序，用于检测远程服务器是否声明支持最新版次的超文本传输协议栈环境状况信息反馈情况分析判断逻辑流程图绘制思路概述总结归纳结论得出最终答案呈现形式表达清晰简洁明了易于理解便于维护扩展升级迭代演进方向指引明确具体可行性强可操作性高具有较高实用价值意义非凡值得推广普及应用范围广泛前景广阔潜力巨大不可限量令人期待满怀憧憬充满希望未来可期！