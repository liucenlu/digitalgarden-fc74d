---
{"dg-publish":true,"permalink":"/前端八股/网络相关/TCP/Tcp三次握手四次挥手/"}
---

为什么建立Tcp链接需要三次握手，两次不可以么？为什么？

两次握手只能保证单向连接是畅通的 第一步，客户端给服务端发送一条消息：你好，服务端。第二步，服务端收到消息，同时给客户端回复一条消息：收到！你好客户端。 这样的两次握手过程， 客户端给服务端打招呼，服务端收到了，说明客户端可以正常给服务端发送数据。但是服务端给客户端打招呼，服务端没有收到反馈，也就不能确保服务端是否能正常给客户端发送消息。 只有经过第三次握手，才能确保双向都可以接收到对方发送的数据。第三步，客户端收到服务端发送的消息，回复：收到！这样就证明了客户端能正常收到服务端的消息。

当然，下面是关于 **TCP 三次握手和四次挥手** 的简明讲解，适合面试中简洁又有逻辑地回答：

---

### ✅ 一、TCP 三次握手（建立连接）

#### **目的：** 建立可靠的双向通信通道，确保客户端和服务端都准备好收发数据。

**过程如下：**

1. **第一次握手**：客户端发送 SYN 报文（SYN=1，Seq=x），表示希望建立连接。
    
2. **第二次握手**：服务器收到后，回复 SYN+ACK 报文（SYN=1，ACK=1，Seq=y，Ack=x+1），表示同意连接并确认客户端的请求。
    
3. **第三次握手**：客户端收到后，回复 ACK 报文（ACK=1，Seq=x+1，Ack=y+1），连接建立完成。
    

✅ 建立完成后，客户端和服务端可以开始数据传输。

---

### ✅ 二、TCP 四次挥手（断开连接）

#### **目的：** 双方都能有序、安全地断开连接。

**过程如下：**

1. **第一次挥手**：客户端发送 FIN 报文，表示“我不发数据了”。
    
2. **第二次挥手**：服务器确认收到，发送 ACK 报文。
    
3. **第三次挥手**：服务器处理完剩余数据后，发送 FIN 报文。
    
4. **第四次挥手**：客户端确认收到 FIN，发送 ACK，之后进入 `TIME_WAIT` 状态。
    

✅ 服务端接收最后一个 ACK 后，正式关闭连接。

---

### ✅ 一句话总结（可作为结尾）：

> “三次握手保证连接可靠建立，四次挥手确保双方都安全断开连接。”

#### 为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？

虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。在Client发送出最后的ACK回复，但该ACK可能丢失。Server如果没有收到ACK，将不断重复发送FIN片段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。Client会在发送出ACK之后进入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。所谓的2MSL是两倍的MSL(Maximum Segment Lifetime)。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。

#### 如果已经建立了连接，但是客户端突然出现故障了怎么办？

TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75分钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。

[TCP和UDP的区别](TCP和UDP的区别.md)
[Tcp协议如何提高传输效率](Tcp协议如何提高传输效率.md)
[Tcp的拥塞控制](Tcp的拥塞控制.md)
[Tcp如何实现数据传输的可靠性](Tcp如何实现数据传输的可靠性.md)