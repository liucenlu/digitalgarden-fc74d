---
{"dg-publish":true,"permalink":"/前端八股/Webpack和Vite/webpack和vite的区别/","created":"2025-05-26T18:57:39.028+08:00","updated":"2025-06-14T23:39:44.907+08:00"}
---

### 为什么不是webpack，和vite相比的区别？

- 答
    
    是的，我这个项目用的是 Vite，其实最初选它主要是因为它**上手快、开发体验非常流畅**。我也了解 Webpack，但对比下来，Vite 在开发阶段的性能优势特别明显。
    
    具体来说，Vite 和 Webpack 最大的区别在于：
    
    1. **启动速度**：
        
        Webpack 在开发时会一次性打包整个项目，项目稍微大一点就比较卡。Vite 用的是浏览器原生的 ES Module（ESM）加载机制，不打包就能启动，**冷启动几乎是秒开**，非常适合前期快速开发。
        
    2. **热更新（HMR）速度**：
        
        Webpack 的热更新需要重新打包依赖，尤其是多层模块时更新慢；而 Vite 会按需更新模块，只更新变化的部分，**HMR 非常快，几乎是即时反馈**，对前端调试体验提升特别大。
        
    3. **构建方式**：
        
        Vite 开发阶段用原生模块，构建阶段是用 `Rollup` 打包的，输出更小更优化。Webpack 则全流程都靠自身打包，构建灵活但配置复杂。
        
    4. **配置复杂度**：
        
        Webpack 功能很强大，但配置文件可能比较复杂，很多 loader 和 plugin 需要手动配。而 Vite 默认配置已经很友好，大部分时候开箱即用，更适合像我们这种中小型项目。


### 如果被追问：“那 Webpack 有什么优点？为什么大项目很多还是用 Webpack？”

✅ 回答补充：

确实，Webpack 更适合**复杂、需要高度自定义的大型项目**，它的插件生态特别成熟，比如多入口配置、SSR 支持、构建分析等等都很强。如果后期项目变复杂了，或者需要服务端渲染，其实也可以考虑迁移到 Webpack 或 Nuxt 等方案。

## ✅ 1. Vite 中~跨域，配置代理

### ❓ 面试官问：

你提到前后端分离，那你项目里怎么处理**跨域**的？Vite 里怎么配置代理？

---

### ✅ 回答：

我们项目是前后端分离开发的，开发时前端运行在本地 8091 端口，后端在 8099，就会产生跨域问题。

为了解决这个问题，我在 `vite.config.js` 里配置了 `server.proxy`，把前缀比如 `/api` 的请求代理到后端地址。

```
// vite.config.js
export default defineConfig({
  server: {
    proxy: {
      '/api': {
        target: '<http://localhost:8080>',
        changeOrigin: true,
        rewrite: path => path.replace(/^\\/api/, '')
      }
    }
  }
})

```

这样我们前端请求 `/api/login`，实际就会转发到 `http://localhost:8080/login`，跨域问题就解决了。

---

## ✅ 2. Vue3 中 `setup()` 有什么优势？你在项目中是怎么使用的？

### ❓ 面试官问：

你项目中用的是 Vue3，可以说说你对 `setup()` 的理解吗？它相对于 Vue2 有什么提升？

---

### ✅ 回答：

在 Vue3 中，`setup()` 是 Composition API 的核心入口，所有响应式变量、生命周期、方法都写在里面。

相对于 Vue2 的 Options API，Vue3 的 `setup()` 更加**逻辑聚合**，能让**相同功能的逻辑写在一起**，不容易分散在 data、methods、watch 里，提高了可维护性。

在项目中比如用户登录模块，我就用 `ref()` 管理输入框数据，用 `watch()` 监听变化，然后用 `onMounted()` 获取初始化数据，逻辑都集中在 `setup()` 中，结构非常清晰。

---

## ✅ 3. Element Plus 和 Element UI 有什么区别？为什么你选了 Element Plus？

### ❓ 面试官问：

你用的是 Element Plus，而不是 Element UI，可以说说它们有什么区别吗？你为什么选它？

---

### ✅ 回答：

Element Plus 是 Element UI 的 Vue3 版本，专门为 Vue3 做了适配。

区别主要有三个：

1. **兼容性**：Element UI 是基于 Vue2 的，而 Element Plus 完全支持 Vue3 和 Composition API。
2. **组件按需加载**：Element Plus 支持 `auto-import` 插件，组件可以自动按需引入，减小打包体积。
3. **性能优化**：Element Plus 的表格组件等重构过，在大数据量处理上更流畅。

我选 Element Plus 是因为我们项目是 Vue3 + Vite 的技术栈，直接用 Element Plus 不仅兼容好，而且社区维护活跃。

---

## ✅ 4. 项目中如何做性能优化？有没有用到节流/防抖？

### ❓ 面试官问：

你提到关注性能优化，具体做过哪些？有没有用到节流或防抖？

---

### ✅ 回答：

有的，我们页面有搜索框，当用户输入关键词时会发请求去查询商品信息，如果不加限制会造成很多无用请求。

我用 `lodash` 的 `debounce` 方法做了输入防抖，设置 500ms，只在用户停止输入后再触发请求：

```
import debounce from 'lodash/debounce'

const onInput = debounce((value) => {
  fetchProductList(value)
}, 500)

```

另外，对于表格滚动加载数据时，我也用过节流函数来限制滚动事件的触发频率，避免卡顿。

---

## ✅ 5. Kafka 和 WebSocket 的区别？在项目中是如何配合使用的？

### ❓ 面试官问：

你提到用了 Kafka 和 WebSocket，它们分别起什么作用？怎么联动实现实时数据推送的？

---

### ✅ 回答：

Kafka 和 WebSocket 在项目中分别承担“数据流管道”和“前端展示”的职责：

- **Kafka** 是后端的消息队列，用来处理大量实时日志、监控数据。我们在数仓项目中，用 Kafka 把设备上报的数据（如温湿度、设备状态）实时收集，并写入缓存或数据库。
- **WebSocket** 是前端和后端之间建立的长连接，用来实现实时双向通信。

我的实现是这样的：

1. Kafka 收到数据后，由后端服务消费（比如 Node 或 PHP 后端）。
2. 后端服务通过 WebSocket，把新数据推送到前端仪表盘页面。
3. 前端收到消息后，动态更新 ECharts 图表。

这样用户可以第一时间看到设备运行状态或异常告警。

---

## ✅ 6. ECharts 中如何实现图表联动和数据钻取？

### ❓ 面试官问：

你做了数据可视化展示，能具体讲讲图表联动是怎么实现的吗？有没有做过钻取功能？

---

### ✅ 回答：

有的，我用过 ECharts 的联动和下钻功能。

- **图表联动**：比如点击柱状图上的一个区域，会同步更新折线图或地图。
    
    实现方式是利用 ECharts 的 `dispatchAction` 和 `on('click')`：
    
    ```
    chart.on('click', function (params) {
      otherChart.dispatchAction({
        type: 'highlight',
        seriesIndex: 0,
        dataIndex: params.dataIndex
      })
    })
    
    ```
    
- **数据钻取**：我们在图表中点击某类商品，可以下钻到各个机器的销量明细。
    
    具体做法是点击事件触发后，通过 API 获取子层级数据，重新设置 `option`。
    

---

## ✅ 7. MySQL 数据库表如何设计？有哪些优化手段？

### ❓ 面试官问：

你设计了数据库，有哪些关键表？如何保证查询效率？有没有用过索引？

---

### ✅ 回答：

我们系统主要设计了四个核心表：用户表、设备表、商品表、订单表。

例如订单表字段包括：

- 订单号（主键）
- 用户ID（外键）
- 商品ID（外键）
- 设备ID（外键）
- 数量、金额、状态、时间戳等

优化上我做了以下几点：

1. **加索引**：对 `用户ID`、`设备ID` 和 `创建时间` 加了索引，提升查询性能。
2. **字段设计**：避免使用过长字段或无用字段，使用合适的数据类型，比如 `DECIMAL(10,2)` 存金额。
3. **范式设计**：采用第三范式，数据冗余少，便于维护。

在高并发时，我也了解并用过**悲观锁**（如 `SELECT FOR UPDATE`）来避免订单重复扣库存。

---

## ✅ 8. 系统中如何实现权限控制与登录鉴权？

### ❓ 面试官问：

用户登录后，你是如何鉴权的？有没有做权限控制？

---

### ✅ 回答：

我实现了基础的权限控制和登录鉴权：

- 登录时，用户输入用户名密码，后端用 PHP 校验数据库信息。
- 登录成功后，后端生成一个 **JWT Token** 或 Session，并返回给前端，保存在 `localStorage`。
- 每次请求，前端通过 `Axios` 请求头带上 Token，后端验证身份。

权限控制方面：

- 用户有不同角色（如管理员、普通用户），数据库有 `role` 字段。
- 前端根据角色展示不同菜单；后端接口也会校验权限，防止越权访问。

例如：普通用户不能访问商品添加接口，管理员才能。